# Socket 网络编程基础

## 前言

Netty 的定位是 Java 的网络通信框架，它在底层也需要用到操作系统向应用层提供的 Socket 系统调用，所以我们在[《图解 Netty 源码》](/netty_source_code_parsing/ready_to_go/introduce)主线任务的第一篇文章中先来讲解一下 Socket 网络编程

有关计算机网络分层想必大家多多少少都有一些了解，有很多种不同的分层方式，本文就选用 TCP/IP 协议分层展开讲解

TCP/IP 协议分层自顶向下包括

* **应用层**：负责与用户交互并处理特定的应用需求，如 HTTP、FTP、SMTP 等协议
* **传输层**：负责端到端的数据传输，常见的协议有 TCP 和 UDP
* **网络层**：负责在不同网络之间路由数据包，IP 协议是网络层的核心
* **链路层**：负责数据帧的传输和物理链路的管理，包括以太网等协议

如下图所示

![image-20241029221357740](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/image-20241029221357740.png)



由此可推测，开发者如需开发位于应用层的 APP 则需要使用 **操作系统提供给用户的TCP或者UDP的系统调用** 进行网络相关的编程

那么这个系统调用是什么呢？我们如何去调用呢？

对，这就是 Socket

![image-20241029221645821](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/image-20241029221645821.png)

原来Socket在这里

**Socket 是什么呢？**

Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个 **门面模式**，它把复杂的 TCP/IP 协议族**隐藏**在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。

**你会使用它们吗？**

前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到 Socket 编程，觉得它是比较高深的编程知识，但是只要弄清 Socket 编程的工作原理，神秘的面纱也就揭开了。

一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理，也许 TCP/IP 协议族就是诞生于生活中，这也说不准。

## 什么是 Socket？

**socket 一词的起源**

在计算机组网领域中，`socket` 一词首次出现在 1970 年 2 月 12 日发布的文献 **IETF RFC33** 中，撰写者为 Stephen Carr、Steve Crocker 和 Vint Cerf。根据美国计算机历史博物馆的记载，Crocker 写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”

计算机历史博物馆补充道：“这比 BSD 套接字接口的定义早了大约 12 年。”

---

上面我们已经了解到网络中的进程是通过 `socket` 进行通信的。那么，什么是 **socket** 呢？

`socket` 起源于 Unix，而 Unix/Linux 的一个基本哲学是 “一切皆文件” ，都可以使用 “打开 `open` → 读写 `write/read` → 关闭 `close`” 的模式进行操作。

可以理解为，`socket` 就是这种模式的一个实现：它是一种特殊的文件，允许我们使用各种 `socket` 函数对其进行操作（例如读/写 IO、打开和关闭）。接下来，我们会基于 **C语言** 进一步介绍这些函数的具体作用。

## 基本 TCP 套接字编程

先来看看《UNIX网络编程 卷1》 中的 **基本TCP客户/服务器程序的套接字函数**

<img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202411012320971.png" alt="image-20241101232014889" style="zoom: 67%;" />





### 创建套接字

```c
// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器)
int socket(int domain, int type, int protocol);
```

为执行网络 I/O，进程的第一步是调用 `socket` 函数（本质上是打开网络文件），并指定所需的通信协议类型（如 **IPv4** 的 **TCP**、**IPv6** 的 **UDP**、**Unix** 域字节流协议等）。

**参数说明：**

- **domain** 参数：指定协议族，即你想要使用的协议（**IPv4**、**IPv6** 等）。该参数也称为协议域，常见的取值如下：

  | domain     | 说明        |
  | ---------- | ----------- |
  | `AF_INET`  | IPv4 协议   |
  | `AF_INET6` | IPv6 协议   |
  | `AF_LOCAL` | Unix 域协议 |
  | `AF_ROUTE` | 路由套接字  |
  | `AF_KEY`   | 密钥套接字  |

  **规定**：本例中所用的套接字协议为 `AF_INET`（即 IPv4 协议）。

- **type** 参数：指定套接字的类型，常见的取值如下：

  | type             | 说明           |
  | ---------------- | -------------- |
  | `SOCK_STREAM`    | 字节流套接字   |
  | `SOCK_DGRAM`     | 数据报套接字   |
  | `SOCK_SEQPACKET` | 有序分组套接字 |
  | `SOCK_RAW`       | 原始套接字     |

  **说明**：若使用 **TCP** 通信，则套接字类型应设为 `SOCK_STREAM`；若为 **UDP** 通信，则使用 `SOCK_DGRAM`。

- **protocol** 参数：指定协议类别，如 **TCP** 或 **UDP**。一般情况下，该字段设置为 `0` 即可，表示默认协议。系统会根据前两个参数自动推导出适用的协议。

  | protocol       | 说明          |
  | -------------- | ------------- |
  | `IPPROTO_TCP`  | TCP 传输协议  |
  | `IPPROTO_UDP`  | UDP 传输协议  |
  | `IPPROTO_SCTP` | SCTP 传输协议 |

**返回值说明：**

套接字创建成功则返回文件描述符；若创建失败，返回值为 `-1`，同时设置错误码。

### 绑定端口号

```c
// 绑定端口号 (TCP/UDP, 服务器)
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

`bind` 函数用于将协议地址赋予一个套接字。

**参数说明：**

- **sockfd** 参数：要绑定的文件描述符，即在创建套接字时获得的文件描述符。
- **addr** 参数：指向特定协议的地址结构的指针，包含协议族、端口号和 IP 地址等信息（详见下一节关于 `sockaddr` 结构的介绍）。
- **addrlen** 参数：该协议地址结构的长度。

**返回值说明：**

绑定成功则返回 `0`，若绑定失败返回 `-1`，并设置错误码。

### 监听套接字

```c
// 开始监听socket (TCP, 服务器)
int listen(int sockfd, int backlog);
```

`listen` 函数通常由 **TCP 服务器**调用，用于向外宣告服务器愿意接受连接请求，并执行以下两项操作：

1. **转换为被动套接字**：当 `socket` 函数创建套接字时，它默认是主动套接字，即用于客户端发起连接的套接字。`listen` 函数将未连接的套接字转换为被动套接字，指示内核接受对该套接字的连接请求。简单来说，服务器调用 `listen` 即告知客户端它可以接受连接。
2. **设置最大连接数**：第二个参数指定内核为该套接字排队的最大连接数。`backlog` 提供了一个提示，表明系统应为该进程排队的未完成连接请求数量。对于 **TCP**，默认值为 **128**。
   - 当队列满时，系统会拒绝多余的连接请求。因此，`backlog` 的值应根据服务器期望的负载和处理能力来选择，其中处理能力指的是可以接受和启动服务的连接数量。

一旦调用了 `listen`，套接字便可以接受连接请求。连接请求可通过 `accept` 函数来处理并建立连接。

**返回值**：成功返回 `0`，失败则返回 `-1`。

**注意**：该函数通常应在调用 `socket` 和 `bind` 后使用，并且在调用 `accept` 之前调用。

---

为了理解 `backlog` 参数，我们需要认识到内核为任何给定的 **监听套接字** 维护两个队列：

1. **未完成连接队列**（incomplete connection queue）：每个这样的 **SYN** 分节对应队列中的一项，这些分节已由某个客户端发送并到达服务器，但服务器正在等待完成相应的 **TCP 三路握手** 过程。这些套接字处于 **SYN RCVD** 状态。
2. **已完成连接队列**（completed connection queue）：每个已完成 **TCP 三路握手** 过程的客户端对应队列中的一项，这些套接字处于 **ESTABLISHED** 状态。

<img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202411012348529.png" alt="image-20241101234824469" style="zoom: 80%;" />

每当在 **未完成连接队列** 中创建一项时，来自 **监听套接字** 的参数会被复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程的插手。



### 接受请求

```c
// 接收请求 (TCP, 服务器)
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

`accept` 函数由 **TCP 服务器** 调用，用于从已完成连接队列中返回下一个已完成连接。如果已完成连接队列为空，进程将进入休眠状态。

如果 `accept` 成功，返回值是内核自动生成的一个全新描述符，表示与所返回客户端的 **TCP** 连接。通常，我们称其第一个参数为 **监听套接字**（listening socket）描述符（由 `socket` 创建，并用作 `bind` 和 `listen` 的第一个参数），而将返回值称为 **已连接套接字**（connected socket）描述符。区分这两个套接字非常重要：

- 一个服务器通常仅创建一个 **监听套接字**，该套接字在服务器的生命周期内一直存在。
- 内核为每个由服务器进程接受的客户连接创建一个 **已连接套接字**，这意味着其 **TCP** 三次握手过程已经完成。
- 当服务器完成对某个特定客户的服务时，相应的 **已连接套接字** 就会被关闭。

总的来说，`accept` 返回的文件描述符是一个新的套接字描述符，连接到调用 `connect` 的客户端。这个新的套接字描述符与原始套接字（`sockfd`）具有相同的套接字类型和地址族。传给 `accept` 的原始套接字仍然保持监听状态，以接受其他连接请求。

### 建立连接

```c
// 建立连接 (TCP, 客户端)
#included <sys/socket.h>
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

**`connect`** 函数用于 **TCP 客户端** 与 **TCP 服务器** 建立连接。

**参数说明：**

- **sockfd** 参数：由 `socket` 函数返回的套接字描述符。
- **第二个参数**：指向套接字地址结构的指针，表示目标服务器的地址。
- **第三个参数**：该结构的大小。

在 `connect` 中指定的地址是我们希望与之通信的服务器地址。如果 `sockfd` 没有绑定到一个地址，`connect` 将为调用者绑定一个默认地址。

**返回值说明：**

- 成功时返回 `0`，出错时返回 `-1`。

### 关闭连接

![image-20241102000601634](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202411020006694.png)

1. 客户端调用 **`close`**，表明没有数据需要发送，此时会向服务器发送 **FIN** 报文，并进入 **FIN WAIT 1** 状态。
2. 服务器接收到 **FIN** 报文后，TCP 协议栈会为 **FIN** 包插入一个文件结束符 **EOF** 到接收缓冲区中，应用程序可以通过 **`read`** 调用来感知这个 **FIN** 包。这个 **EOF** 会被放在已排队的其他已接收数据之后，这意味着服务器需要处理这种异常情况，因为 **EOF** 表示在该连接上不会再有额外数据到达。此时，服务器进入 **CLOSE WAIT** 状态。
3. 接着，服务器处理完数据后，自然会读取到 **EOF**，于是也调用 **`close`** 关闭它的套接字，这会使得服务器发出一个 **FIN** 包，之后处于 **LAST ACK** 状态。
4. 客户端接收到服务器的 **FIN** 包，并发送 **ACK** 确认包给服务器，此时客户端将进入 **TIME WAIT** 状态。
5. 服务器收到 **ACK** 确认包后，就进入了最后的 **CLOSE** 状态。
6. 客户端经过 **2MSL** 时间之后，也进入 **CLOSE** 状态。

### 读写数据

![image-20241102001726163](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202411020017295.png)

#### read/write的语义：为什么会阻塞？

先从 `write` 说起：

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

首先，`write` 成功返回，仅意味着 `buf` 中的数据被复制到了内核中的 TCP 发送缓冲区。至于数据何时被发送到网络、何时被对方主机接收、何时被对方进程读取，系统调用层面并不提供任何保证和通知。

**write 在什么情况下会阻塞？** 当内核的该 `socket` 的发送缓冲区已满时。对于每个 `socket`，都有其自己的发送 (`send buffer`) 和接收缓冲区 (`receive buffer`)。从 Linux 2.6 开始，这两个缓冲区的大小由系统自动调整（`autotuning`），但通常在默认值和最大值之间浮动。

**获取 `socket` 的发送/接收缓冲区的大小**：

```c
sysctl net.core.wmem_default       # 126976
sysctl net.core.wmem_max           # 131071
```

已发送到网络的数据仍需要暂存在发送缓冲区中，只有收到对方的 `ack` 后，内核才会从缓冲区中清除相应数据，为后续发送的数据腾出空间。接收端将收到的数据暂存在接收缓冲区中，自动进行确认。如果 `socket` 所在的进程未及时从接收缓冲区中取出数据，最终会导致缓冲区填满。由于 TCP 的滑动窗口和拥塞控制，接收端会阻止发送端向其发送数据。这些控制都发生在 TCP/IP 栈中，对应用程序透明。若应用程序继续发送数据，最终会导致 `send buffer` 填满，`write` 调用阻塞。

一般来说，由于接收端进程从 `socket` 读取数据的速度不及发送端写入 `socket` 的速度，最终会导致发送端的 `write` 调用阻塞。

而 `read` 调用的行为相对容易理解，即从 `socket` 的接收缓冲区中拷贝数据到应用程序的缓冲区。**`read` 调用阻塞的原因通常是发送端数据未到达**。

------

####  **blocking（默认）和 nonblock 模式下 `read/write` 行为的区别**

将 `socket` 文件描述符设置为非阻塞模式 (`nonblock`) 是服务器编程中的常见做法。使用阻塞 `I/O` 并为每个客户端创建一个线程的模式开销巨大，且可扩展性不佳（带来大量的上下文切换开销）。更为通用的做法是采用 **线程池 + Nonblock I/O + 多路复用**（`select/poll` 以及 Linux 上特有的 `epoll`）。

```c
// 设置一个文件描述符为非阻塞模式
int set_nonblocking(int fd) {
    int flags;
    if ((flags = fcntl(fd, F_GETFL, 0)) == -1)
        flags = 0;
    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}
```

**几个重要的结论**：

1. **`read` 总是在接收缓冲区有数据时立即返回**，而不是等到填满整个 `read buffer`。只有当接收缓冲区为空时，阻塞模式会等待；非阻塞模式下会立即返回 `-1`（`errno = EAGAIN` 或 `EWOULDBLOCK`）。

2. **阻塞模式的 `write` 只有在缓冲区足以容纳整个 `buffer` 时才返回**（与阻塞模式的 `read` 不同）。非阻塞模式的 `write` 则返回能够写入的字节数，之后调用会返回 `-1`（`errno = EAGAIN` 或 `EWOULDBLOCK`）。

   阻塞模式的 `write` 有一个特例：当 `write` 正阻塞等待时，对方关闭了 `socket`，则 `write` 会立即填满剩余缓冲区并返回写入的字节数；再次调用 `write` 则会失败（`connection reset by peer`）。

------

#### **`read/write` 对连接异常的反馈行为**

对于应用程序而言，与另一进程的 TCP 通信其实是一个完全异步的过程：

1. 不确定对方何时、是否收到数据。
2. 不知道何时能够收到对方数据。
3. 不确定通信何时结束（可能由于主动退出、异常退出、机器故障或网络故障）。

对于前两点，可以通过 `write() -> read() -> write() -> read() ->...` 的序列操作，配合阻塞 `read` 或非阻塞 `read` + 轮询方式来正确处理。

对于第三点，内核通过 `read/write` 的结果将事件“通知”应用层。

假设 A 机器上的进程 `a` 正在和 B 机器上的进程 `b` 通信，某一时刻 `a` 阻塞在 `socket` 的 `read` 调用上（或在非阻塞模式下轮询 `socket`）。当进程 `b` 终止时，无论应用程序是否显式关闭 `socket`，OS 都会负责关闭所有文件描述符，并发送一个 `FIN` 包至对端。

**“同步通知”**：进程 `a` 在已收到 `FIN` 的 `socket` 上调用 `read`，若已读完接收缓冲区剩余字节，则返回 `EOF:0`。

**“异步通知”**：若进程 `a` 阻塞在 `read` 上（接收缓冲区为空时 `read` 会阻塞），则调用 `read` 会立即返回 `EOF`，唤醒进程 `a`。

**异常情况**：假如进程 `b` 异常终止，OS 会为其所有打开的 `socket` 发送 `RST`（因为 `socket` 所属进程已终止）。此时，进程 `a` 调用 `write` 会收到 `SIGPIPE`，默认处理是终止进程，这就解释了进程为何可能会“毫无征兆”地终止。

------

#### **还需要做什么？**

我们知道，仅仅通过 `read/write` 检测异常情况并不完全可靠，因此还需一些额外手段：

1. **TCP 的 `KEEPALIVE` 功能**：

   ```c
   cat /proc/sys/net/ipv4/tcp_keepalive_time       # 7200 秒
   cat /proc/sys/net/ipv4/tcp_keepalive_intvl      # 75 秒
   cat /proc/sys/net/ipv4/tcp_keepalive_probes     # 9 次
   ```

   以上参数含义为：`keepalive` 每 2 小时（7200 秒）启动一次，发送第一个探测包，若在 75 秒内未收到应答则重发探测包，连续 9 次未应答则认为连接已断开。此时，`read` 应返回错误。

2. **应用层心跳**：

   在严格的网络程序中，应用层心跳协议是必不可少的。虽然比 TCP 自带的 `keepalive` 要复杂一些，但更为可控。

## 简单的 TCP 网络程序

### 客户端

![image-20241101234241863](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202411012342985.png)

### 服务器

![img](https://i-blog.csdnimg.cn/blog_migrate/7e5d1638a844dd58219c1ec5b56293fe.png)

## 总结

通过Socket编程，开发者能够实现高效的网络通信。理解TCP/IP协议族的层次结构以及Socket的基本操作，是进行网络编程的基础。Socket的使用简化了网络通信的复杂性，使得开发者可以专注于应用的业务逻辑，而无需深入底层的网络细节。



## 参考

* [基本的TCP套接字编程（详解）-CSDN博客](https://blog.csdn.net/sjsjnsjnn/article/details/127011817)
* [【Networkk】一篇文章完全搞清楚 scoket read/write 返回码、阻塞与非阻塞、异常处理 等让你头疼已久的问题 - junneyang - 博客园](https://www.cnblogs.com/junneyang/p/6126635.html)
* [UNIX网络编程 卷1：套接字联网API（第3版） (豆瓣)](https://book.douban.com/subject/26434583/)